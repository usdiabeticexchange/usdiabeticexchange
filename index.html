<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<!-- Price sync + Cart override (Google Sheets) -->
<script>
(() => {
  if (window.__PRICE_SYNC_RUNNING__) return;
  window.__PRICE_SYNC_RUNNING__ = true;

  const CSV_URL =
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';

  const DEBUG = false; // set to true if you want logs

  // Which column to use based on select label
  const EXP_KEYS = [
    { test: /9\+|\b9\s*months?/i, col: 'p9'  },
    { test: /\b7\s*[-–]\s*8|\b7-8/i, col: 'p78' },
    { test: /\b6\s*months?/i,     col: 'p6'  }
  ];

  // Optional title fixes
  const ALIAS = {
    // 'MMT-242': 'MMT 242',
  };

  // ---------- utils ----------
  const norm = s => (s||'')
    .toLowerCase()
    .replace(/™|®/g,'')
    .replace(/[^a-z0-9]+/g,' ')
    .replace(/\s+/g,' ')
    .trim();

  const toNum = v => {
    const n = Number(String(v ?? '').replace(/[^\d.]/g,''));
    return Number.isFinite(n) ? n : null;
  };
  const fmt = n => '$' + Number(n).toFixed(2);

  const pickColFromLabelText = txt => {
    const t = (txt||'').toString();
    for (const k of EXP_KEYS) if (k.test.test(t)) return k.col;
    return 'p9';
  };

  function findNameEl(card){
    return card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  }
  function findPriceEl(card){
    const cands = card.querySelectorAll(
      '[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]'
    );
    for (const el of cands) if (/\$\s*\d/.test((el.textContent||'').trim())) return el;
    return cands[0] || null;
  }
  const findSelect = card => card.querySelector('select');

  // Keep green style and avoid “$8.00” + “5.00” concatenation
  function setPriceKeepingStyle(el, value){
    if (!el) return;
    el.textContent = fmt(value);
    try {
      const cls = el.classList;
      const hasGreen = Array.from(cls).some(c => c === 'text-success' || c.startsWith('text-green'));
      if (!hasGreen) cls.add('text-green-600', 'font-semibold');
    } catch {}
  }

  function findAllCards(){
    const btns = [...document.querySelectorAll('button')].filter(b => /add to sale/i.test(b.textContent||''));
    const cards = [];
    for (const b of btns){
      let root = b.closest('[data-product-card], .product-card, .bg-white, .card') || b.parentElement;
      for (let i=0;i<8 && root;i++){
        if (findNameEl(root) && (findPriceEl(root) || root.querySelector('[class*="text-green"]'))) break;
        root = root.parentElement;
      }
      if (root && !cards.includes(root)) cards.push(root);
    }
    return cards;
  }

  // ---------- sheet index ----------
  let PRICE_INDEX = [];  // [{key,tokens,row:{p9,p78,p6}}]
  function buildIndex(rows){
    const idx = [];
    for (const r of rows){
      const name = r.product_name || r.Product_Name || r.name || r.Name || r.product || r.Product;
      if (!name) continue;
      const key = norm(name);
      idx.push({
        key,
        tokens: new Set(key.split(' ')),
        row: {
          p9:  toNum(r['9+ months until expiration'] ?? r['9 months until expiration'] ?? r.price_9plus ?? r['9+'] ?? r['9_plus'] ?? r['9 mo']),
          p78: toNum(r['7-8 months until expiration'] ?? r.price_7to8 ?? r['7-8'] ?? r['7_to_8'] ?? r['7-8 mo']),
          p6:  toNum(r['6 months until expiration']   ?? r.price_6   ?? r['6']   ?? r['6 mo']      ?? r['6_months']),
        }
      });
    }
    return idx;
  }

  function resolveRow(visibleName){
    const alias = ALIAS[visibleName] || visibleName;
    const key = norm(alias);
    if (!key) return null;
    const exact = PRICE_INDEX.find(e => e.key === key);
    if (exact) return exact.row;

    const tokens = key.split(' ').filter(Boolean);
    let best=null, score=-1;
    for (const e of PRICE_INDEX){
      let s=0;
      for (const t of tokens){
        if (e.tokens.has(t)){
          s += 1;
          if (/^\d+$/.test(t)) s += 0.75;
          if (t.length >= 5)  s += 0.25;
        }
      }
      if (s>score){ score=s; best=e; }
    }
    return score >= 2 ? best.row : null;
  }

  function resolvePriceByNameAndLabel(name, labelText){
    const row = resolveRow(name);
    if (!row) return null;
    const col = pickColFromLabelText(labelText);
    return row[col] ?? row.p9 ?? null;
  }

  // ---------- apply to product cards with cache key ----------
  function applyToCard(card){
    const nameEl  = findNameEl(card);
    const priceEl = findPriceEl(card);
    if (!nameEl || !priceEl) return false;

    const sel = findSelect(card);
    const labelText = sel?.options?.[sel.selectedIndex]?.textContent || '';
    const nameText  = (nameEl.textContent||'').trim();

    const val = resolvePriceByNameAndLabel(nameText, labelText);
    if (val == null) return false;

    const key = labelText + '|' + val;
    if (card.dataset.psAppliedKey === key) return false; // no change since last time

    setPriceKeepingStyle(priceEl, val);
    card.dataset.psAppliedKey = key;

    // bind once so switching expiration updates price
    if (sel && !sel.dataset.boundPriceSync){
      sel.addEventListener('change', () => applyToCard(card));
      sel.dataset.boundPriceSync = '1';
    }
    return true;
  }

  // ---------- cart override ----------
  function findCartRoot(){
    // Try common dialog containers
    const dialogs = [...document.querySelectorAll('[role="dialog"], [aria-modal="true"], .fixed, .drawer, .modal')];
    for (const d of dialogs){
      const txt = (d.textContent||'').toLowerCase();
      if (txt.includes('your sale items') || txt.includes('total value')) return d;
    }
    return null;
  }

  function getQtyFromRow(row){
    // Try input number
    const inp = row.querySelector('input[type="number"]');
    if (inp){
      const n = parseInt(inp.value || inp.getAttribute('value') || '1', 10);
      return Number.isFinite(n) ? n : 1;
    }
    // Try text between minus/plus
    const btnMinus = row.querySelector('button');
    if (btnMinus && btnMinus.nextElementSibling){
      const t = btnMinus.nextElementSibling.textContent || '';
      const n = parseInt(t.replace(/[^\d]/g,''), 10);
      if (Number.isFinite(n)) return n;
    }
    // Fallback 1
    return 1;
  }

  function syncCartPrices(){
    const root = findCartRoot();
    if (!root) return false;

    // Find candidate rows: things that have a plus or minus button OR look like an item line
    const rows = [...root.querySelectorAll('div,li,section,article')].filter(el =>
      /\+\s*$/.test(el.textContent||'') || /–|-/.test(el.textContent||'')
    );

    let any = false;
    let total = 0;

    // Build a quick map of visible names (from cards) to price function
    const cardNames = new Set(findAllCards().map(c => (findNameEl(c)?.textContent||'').trim()));

    // Walk rows, try to detect a product name and replace prices
    rows.forEach(row => {
      // name: first element with some bold/heading, else longest line
      let nameEl = row.querySelector('h3,h4,strong,.font-semibold,.card-title,[data-product-name]');
      let name = (nameEl?.textContent || '').trim();
      if (!name){
        const parts = (row.textContent||'').split('\n').map(s=>s.trim()).filter(Boolean);
        name = parts.sort((a,b)=>b.length-a.length)[0] || '';
      }
      if (!name) return;

      // Only try for names we likely have on page or in sheet
      const rowData = resolveRow(name);
      if (!rowData && !cardNames.has(name)) return;

      // label (expiration) — grab a select near the row, else assume 9+
      const sel = row.querySelector('select');
      const labelText = sel?.options?.[sel.selectedIndex]?.textContent || '9+ months until expiration';
      const price = resolvePriceByNameAndLabel(name, labelText);
      if (price == null) return;

      // Replace any $x.xx text nodes in the row
      const moneyEls = [...row.querySelectorAll('*')].filter(e => /\$\s*\d/.test((e.textContent||'')));
      if (moneyEls.length){
        moneyEls.forEach(e => {
          // If element contains something like "$35 each", keep the suffix
          const m = (e.textContent||'').match(/(\$)\s*\d[\d.,]*/);
          if (m){
            e.textContent = (e.textContent||'').replace(/\$\s*\d[\d.,]*/, fmt(price));
          }
        });
      }
      // Update “each” blurb if present
      const eachEl = [...row.querySelectorAll('*')].find(e => /each/i.test(e.textContent||''));
      if (eachEl){
        eachEl.textContent = (eachEl.textContent||'').replace(/\$\s*\d[\d.,]*/, fmt(price));
      }

      const qty = getQtyFromRow(row);
      total += (price * qty);
      any = true;
    });

    // Totals in drawer (both “Total value:” up top and the big green total)
    if (any){
      const currencyEls = [...root.querySelectorAll('*')].filter(e => /\$\s*\d/.test((e.textContent||'')));
      // Update any element that looks like a total near words "total"
      currencyEls.forEach(el => {
        const t = (el.textContent||'');
        if (/total/i.test(el.parentElement?.textContent||'') || /total value/i.test(root.textContent||'')){
          el.textContent = t.replace(/\$\s*\d[\d.,]*/, fmt(total));
        }
      });
    }
    return any;
  }

  // Run cart sync on drawer changes
  let cartObs;
  function attachCartObserver(){
    const root = document.body;
    if (cartObs) cartObs.disconnect();
    cartObs = new MutationObserver(() => { syncCartPrices(); });
    cartObs.observe(root, { childList:true, subtree:true });
  }

  // ---------- orchestration ----------
  let applyTimer=null, applyQueued=false, productRoot=null;
  function queueApplyAll(){
    if (applyQueued) return;
    applyQueued = true;
    applyTimer = setTimeout(() => {
      applyQueued = false;
      const cards = findAllCards();
      let changed = 0;
      for (const c of cards) if (applyToCard(c)) changed++;
      if (DEBUG) console.log('[price-sync] applied to', cards.length, 'cards; changed', changed, 'prices');
      // also try cart on each pass (cheap)
      syncCartPrices();
    }, 150);
  }

  function observeProducts(){
    // Scope the observer to the smallest container that contains the grid
    const aCard = findAllCards()[0];
    productRoot = aCard ? (aCard.closest('main, [class*="container"], #root') || document.body) : document.body;

    const mo = new MutationObserver(queueApplyAll);
    mo.observe(productRoot, { childList:true, subtree:true }); // not watching characterData
  }

  function start(){
    // Wait a bit for SPA to mount
    let tries=0, max=40;
    (function wait(){
      if (findAllCards().length){
        Papa.parse(CSV_URL + '&cb=' + Date.now(), {
          download:true, header:true, skipEmptyLines:true,
          complete: res => {
            PRICE_INDEX = buildIndex(res.data);
            observeProducts();
            attachCartObserver();
            // initial passes
            queueApplyAll();
            let n=0; const maxN=5;
            (function late(){ queueApplyAll(); if(++n<maxN) setTimeout(late, 600); })();
          },
          error: err => console.error('[price-sync] CSV load error', err),
        });
      } else if (++tries < max){
        setTimeout(wait, 300);
      } else {
        // Give up waiting, still try
        Papa.parse(CSV_URL + '&cb=' + Date.now(), {
          download:true, header:true, skipEmptyLines:true,
          complete: res => { PRICE_INDEX = buildIndex(res.data); observeProducts(); attachCartObserver(); queueApplyAll(); },
          error: err => console.error('[price-sync] CSV load error', err),
        });
      }
    })();
  }

  // Load Papa
  if (typeof Papa === 'undefined'){
    const s=document.createElement('script');
    s.src='https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
    s.onload=start;
    s.onerror=()=>console.error('[price-sync] Failed to load PapaParse');
    document.head.appendChild(s);
  } else {
    start();
  }

  if (DEBUG) console.log('[price-sync] inline script loaded');
})();
</script>








</body>

</html>
