<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<!-- Price sync from Google Sheets (preserves your green styling) -->
<script id="price-sync-google">
(() => {
  console.log('[price-sync] inline script loaded');

  const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';

  const EXP_MAP = {
    '9+ months until expiration': 'price_9plus',
    '9 months until expiration':  'price_9plus',
    '7-8 months until expiration': 'price_7to8',
    '6 months until expiration':   'price_6',
  };

  const ALIAS = {
    // 'Exact card title' : 'Exact sheet name'
  };

  const norm = s => (s || '').toLowerCase().replace(/\s+/g,' ').trim();
  const toNum = v => {
    const n = Number(String(v ?? '').replace(/[^\d.]/g,''));
    return Number.isFinite(n) ? n : null;
  };
  const fmt = n => '$' + Number(n).toFixed(2);

  function findNameEl(card){
    return card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  }

  function findPriceContainer(card){
    // element that *visually* holds the price
    const cands = card.querySelectorAll(
      '[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]'
    );
    // prefer a green/price-ish element
    for (const el of cands) if (/\d/.test(el.textContent || '')) return el;
    // otherwise, try any element whose text currently looks like a price
    for (const el of card.querySelectorAll('*')){
      if (/^\$?\d+(\.\d{1,2})?$/.test((el.textContent || '').trim())) return el;
    }
    return null;
  }

  function findNumberNode(el){
    // 1) a child span whose text is just the number (or $ + number)
    const exact = [...el.querySelectorAll('span, strong, b, i, em')]
      .find(n => /^\$?\d+(\.\d{1,2})?$/.test((n.textContent || '').trim()));
    if (exact) return exact;

    // 2) a direct child text node with digits
    const tn = [...(el.childNodes || [])].find(n => n.nodeType===3 && /\d/.test(n.textContent || ''));
    if (tn) return tn;

    // 3) fallback: return container itself (we’ll replace its text)
    return el;
  }

  function setPrice(el, value){
    if (!el) return;
    const txt = fmt(value);
    const node = findNumberNode(el);

    if (node === el){
      // replace text only; keep element + classes
      el.textContent = txt;
    } else if (node.nodeType === 3){
      node.textContent = txt;             // text node
    } else {
      node.textContent = txt;             // nested <span>/<strong>…
    }

    // ensure green/bold styling remains
    try {
      const cls = el.classList;
      const hasGreen = [...cls].some(c => c==='text-success' || c.startsWith('text-green'));
      if (!hasGreen) cls.add('text-green-600','font-semibold');
    } catch {}
  }

  function dropdownLabel(sel){
    const opt = sel?.options?.[sel.selectedIndex];
    return (opt ? opt.textContent : '').trim() || '9+ months until expiration';
  }

  function findAllCards(){
    const btns = [...document.querySelectorAll('button')].filter(b =>
      /add to sale/i.test(b.textContent || '')
    );
    const cards = btns.map(b =>
      b.closest('[data-product-card], .product-card, .bg-white, .card, .rounded, .border') || b.parentElement
    ).filter(Boolean);
    return [...new Set(cards)];
  }

  function buildMap(rows){
    const map = new Map();
    rows.forEach(r => {
      const name = norm(r.name || r.Name || r.product || r.Product);
      if (!name) return;
      map.set(name, {
        price_9plus: toNum(r.price_9plus ?? r['9+'] ?? r['9_plus'] ?? r['9 mo']),
        price_7to8:  toNum(r.price_7to8  ?? r['7-8'] ?? r['7_to_8'] ?? r['7-8 mo']),
        price_6:     toNum(r.price_6     ?? r['6']   ?? r['6 mo']),
      });
    });
    return map;
  }

  function findRowForCard(map, card){
    const nameEl = findNameEl(card);
    if (!nameEl) return null;
    const visible = (nameEl.textContent || '').trim();
    const key = ALIAS[visible] || visible;
    return map.get(norm(key)) || null;
  }

  function applyPriceToCard(map, card){
    const sel = card.querySelector('select');
    const col = EXP_MAP[dropdownLabel(sel)] || 'price_9plus';
    const row = findRowForCard(map, card);
    if (!row) { card.dataset.priceSyncMissing = '1'; return false; }

    const val = row[col] ?? row.price_9plus;
    if (val == null) return false;

    const priceEl = findPriceContainer(card);
    if (!priceEl) return false;

    // Only update if different
    const current = toNum((priceEl.textContent || '').trim());
    if (current === val) return false;

    setPrice(priceEl, val);
    if (sel && !sel.dataset.bound){
      sel.addEventListener('change', () => applyPriceToCard(map, card));
      sel.dataset.bound = '1';
    }
    return true;
  }

  function hydrate(rows){
    const map = buildMap(rows);

    const applyAll = () => {
      const cards = findAllCards();
      let changed = 0;
      cards.forEach(c => { if (applyPriceToCard(map, c)) changed++; });
      console.log('[price-sync] applied to', cards.length, 'cards');
      console.log('[price-sync] changed', changed, 'prices');
    };

    // run now + for a handful of frames while SPA finishes
    applyAll();
    let tries = 30;
    const tick = () => { applyAll(); if (--tries > 0) requestAnimationFrame(tick); };
    requestAnimationFrame(tick);

    // also watch for DOM changes (tab switches, lazy lists)
    const mo = new MutationObserver(applyAll);
    mo.observe(document.body, { childList:true, subtree:true });
  }

  function start(){
    function run(){
      Papa.parse(CSV_URL + '&cb=' + Date.now(), {
        download:true, header:true, skipEmptyLines:true,
        complete: res => hydrate(res.data),
        error: err => console.error('[price-sync] CSV load error', err),
      });
    }
    if (typeof Papa === 'undefined'){
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
      s.onload = run;
      s.onerror = () => console.error('[price-sync] Failed to load PapaParse');
      document.head.appendChild(s);
    } else run();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', start, { once:true });
  } else {
    start();
  }
})();
</script>





</body>

</html>
