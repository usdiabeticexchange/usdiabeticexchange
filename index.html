<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>

<!-- Google Sheets Price Sync - Optimized Version -->
<script>
(() => {
  // Prevent multiple runs
  if (window.PRICE_SYNC_LOADED) return;
  window.PRICE_SYNC_LOADED = true;

  console.log('[PriceSync] Starting Google Sheets integration...');

  // Configuration
  const CONFIG = {
    CSV_URL: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv',
    UPDATE_INTERVAL: 300000, // 5 minutes
    MAX_RETRIES: 3
  };

  // State
  let priceData = new Map();
  let isLoading = false;
  let retryCount = 0;

  // Utility functions
  const normalizeProductName = (name) => {
    return (name || '').toLowerCase()
      .replace(/™|®/g, '')
      .replace(/[^a-z0-9]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  };

  const formatPrice = (price) => {
    const num = Number(String(price).replace(/[^0-9.]/g, ''));
    return isNaN(num) ? null : `$${num.toFixed(2)}`;
  };

  const parseExpirationCategory = (text) => {
    if (!text) return '9+';
    const t = text.toLowerCase();
    if (t.includes('6 month')) return '6';
    if (t.includes('7') || t.includes('8')) return '7-8';
    return '9+';
  };

  // Find product cards and elements
  const findProductCards = () => {
    const buttons = [...document.querySelectorAll('button')]
      .filter(btn => /add to sale/i.test(btn.textContent || ''));

    return buttons.map(btn => {
      let card = btn.closest('[data-product-card], .product-card, .bg-white, .card');
      if (!card) {
        card = btn.parentElement;
        for (let i = 0; i < 5 && card; i++) {
          if (card.querySelector('h3, h4, .title, [data-product-name]')) break;
          card = card.parentElement;
        }
      }
      return card;
    }).filter(card => card);
  };

  const getProductInfo = (card) => {
    const nameEl = card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
    const priceEl = card.querySelector('[data-price], .price, .product-price, .text-green-600, .text-green-700, .text-success');
    const selectEl = card.querySelector('select');

    if (!nameEl || !priceEl) return null;

    const name = nameEl.textContent?.trim() || '';
    const selectedOption = selectEl?.options[selectEl.selectedIndex];
    const expiration = selectedOption?.textContent || '9+ months until expiration';

    return { nameEl, priceEl, selectEl, name, expiration, card };
  };

  // Load and parse CSV data
  const loadPriceData = async () => {
    if (isLoading) return;
    isLoading = true;

    try {
      console.log('[PriceSync] Fetching price data...');
      const response = await fetch(`${CONFIG.CSV_URL}&cb=${Date.now()}`);

      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      const csvText = await response.text();
      const lines = csvText.split('\n').filter(line => line.trim());
      const headers = lines[0].split(',').map(h => h.trim());

      priceData.clear();

      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim());
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });

        const productName = row['Product_Name'] || row['product_name'] || row['name'] || row['Product'];
        if (!productName) continue;

        const normalized = normalizeProductName(productName);
        priceData.set(normalized, {
          '6': formatPrice(row['6 months until expiration'] || row['6'] || row['6_months']),
          '7-8': formatPrice(row['7-8 months until expiration'] || row['7-8'] || row['7_to_8']),
          '9+': formatPrice(row['9+ months until expiration'] || row['9+'] || row['9_plus'])
        });
      }

      console.log(`[PriceSync] Loaded ${priceData.size} products from spreadsheet`);
      retryCount = 0; // Reset retry count on success

    } catch (error) {
      console.error('[PriceSync] Error loading price data:', error);
      retryCount++;

      if (retryCount < CONFIG.MAX_RETRIES) {
        console.log(`[PriceSync] Retrying in 5 seconds... (${retryCount}/${CONFIG.MAX_RETRIES})`);
        setTimeout(loadPriceData, 5000);
      }
    } finally {
      isLoading = false;
    }
  };

  // Update product prices
  const updateProductPrices = () => {
    if (priceData.size === 0) return;

    const cards = findProductCards();
    let updatedCount = 0;

    cards.forEach(card => {
      const info = getProductInfo(card);
      if (!info) return;

      const { name, expiration, priceEl, selectEl } = info;
      const normalizedName = normalizeProductName(name);
      const expirationCategory = parseExpirationCategory(expiration);

      // Try exact match first
      let prices = priceData.get(normalizedName);

      // If no exact match, try fuzzy matching
      if (!prices) {
        const nameTokens = normalizedName.split(' ').filter(Boolean);
        let bestMatch = null;
        let bestScore = 0;

        for (const [key, value] of priceData) {
          let score = 0;
          nameTokens.forEach(token => {
            if (key.includes(token)) {
              score += token.length > 2 ? 2 : 1;
            }
          });

          if (score > bestScore && score > 2) {
            bestScore = score;
            bestMatch = value;
          }
        }

        prices = bestMatch;
      }

      if (!prices) return;

      const newPrice = prices[expirationCategory] || prices['9+'];
      if (!newPrice) return;

      // Update price display
      const currentPrice = priceEl.textContent?.trim() || '';
      if (currentPrice !== newPrice) {
        priceEl.textContent = newPrice;
        priceEl.dataset.price = newPrice.replace('$', '');

        // Update dropdown options if they exist
        if (selectEl) {
          for (const option of selectEl.options) {
            const optionExpiration = parseExpirationCategory(option.textContent);
            const optionPrice = prices[optionExpiration] || prices['9+'];
            if (optionPrice) {
              const baseText = option.textContent.replace(/\s*-\s*\$[\d.]+$/, '');
              option.textContent = `${baseText} - ${optionPrice}`;
              if (option.selected) {
                option.value = optionPrice.replace('$', '');
              }
            }
          }
        }

        // Update hidden inputs and data attributes
        const hiddenInputs = card.querySelectorAll('input[type="hidden"][name*="price"], [data-price]');
        hiddenInputs.forEach(input => {
          if (input.tagName === 'INPUT') {
            input.value = newPrice.replace('$', '');
          } else {
            input.dataset.price = newPrice.replace('$', '');
          }
        });

        updatedCount++;
      }
    });

    if (updatedCount > 0) {
      console.log(`[PriceSync] Updated ${updatedCount} product prices`);
    }
  };

  // Update cart prices
  const updateCartPrices = () => {
    const cartEl = document.querySelector('[role="dialog"], [aria-modal="true"], [class*="drawer"], [data-cart]');
    if (!cartEl) return;

    const cartItems = [...cartEl.querySelectorAll('*')].filter(el =>
      /^Expiration:/i.test(el.textContent?.trim() || '')
    );

    let cartUpdated = 0;

    cartItems.forEach(item => {
      const container = item.closest('div');
      if (!container) return;

      const nameEl = container.querySelector('h1,h2,h3,h4,.title,.font-medium');
      const priceEl = container.querySelector('*:not(button)');

      if (!nameEl || !priceEl) return;

      const name = nameEl.textContent?.trim() || '';
      const expText = item.textContent.split(':')[1]?.trim() || '';
      const expiration = parseExpirationCategory(expText);

      const normalizedName = normalizeProductName(name);
      const prices = priceData.get(normalizedName);

      if (prices) {
        const newPrice = prices[expiration] || prices['9+'];
        if (newPrice && priceEl.textContent?.includes('$')) {
          priceEl.textContent = priceEl.textContent.replace(/\$[\d.]+/, newPrice);
          cartUpdated++;
        }
      }
    });

    if (cartUpdated > 0) {
      console.log(`[PriceSync] Updated ${cartUpdated} cart items`);
    }
  };

  // Main sync function
  const syncPrices = () => {
    updateProductPrices();
    updateCartPrices();
  };

  // Initialize
  const init = async () => {
    console.log('[PriceSync] Waiting for page content...');

    // Wait for products to load
    let attempts = 0;
    const maxAttempts = 20;

    const waitForProducts = () => {
      const cards = findProductCards();
      if (cards.length > 0) {
        console.log(`[PriceSync] Found ${cards.length} product cards`);
        loadPriceData().then(() => {
          syncPrices();

          // Set up periodic updates
          setInterval(() => {
            loadPriceData().then(syncPrices);
          }, CONFIG.UPDATE_INTERVAL);

          // Watch for DOM changes
          const observer = new MutationObserver(() => {
            clearTimeout(observer.timer);
            observer.timer = setTimeout(syncPrices, 500);
          });

          observer.observe(document.body, {
            childList: true,
            subtree: true
          });

          console.log('[PriceSync] Initialization complete');
        });
      } else if (attempts < maxAttempts) {
        attempts++;
        setTimeout(waitForProducts, 500);
      } else {
        console.warn('[PriceSync] Could not find product cards after waiting');
      }
    };

    waitForProducts();
  };

  // Start when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    setTimeout(init, 100);
  }

  // Expose manual sync function for debugging
  window.PRICE_SYNC_MANUAL = () => {
    console.log('[PriceSync] Manual sync triggered');
    loadPriceData().then(syncPrices);
  };
})();
</script>

</body>

</html>
