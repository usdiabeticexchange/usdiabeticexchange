<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<!-- Price sync from Google Sheets (keeps green styling; robust matching) -->
<script>
(() => {
  const CSV_URL =
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';
  const DEBUG = true;

  // Dropdown label -> sheet column
  const EXP_MAP = {
    '9+ months until expiration': 'price_9plus',
    '9 months until expiration':  'price_9plus',
    '7-8 months until expiration': 'price_7to8',
    '6 months until expiration':   'price_6',
  };

  // Use ALIAS only for true outliers you want to force-match
  const ALIAS = {
    // 'Accu-Chek Aviva 50 Ct. (Mail Order)': 'Accu-Chek Aviva 50 Ct.',
    // 'MMT-242': 'MMT 242',
  };

  // Words we ignore when comparing
  const STOP = new Set([
    'the','and','or','for','with','only','kit','bag','bags','box','sealed','count',
    'pcs','pk','pack','packs','packet','packets','ct','ct.','cartridge','cartridges',
    'infusion','infusions','sets','set','reader','sensors','sensor'
  ]);

  // ---------- helpers ----------
  const norm = s => (s || '').toLowerCase().replace(/\s+/g, ' ').trim();
  const words = s => norm(s).split(/[^a-z0-9+]+/).filter(Boolean).filter(w => !STOP.has(w));
  const nums  = s => (norm(s).match(/\d+/g) || []);
  const toNum = v => {
    const s = String(v ?? '').replace(/[, ]/g,'').replace(/[^\d.]/g,'');
    if (!s) return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  };
  const fmt = n => '$' + Number(n).toFixed(2);

  const labelFor = sel => {
    if (!sel) return '9+ months until expiration';
    const opt = sel.selectedOptions?.[0] || sel.options?.[sel.selectedIndex];
    return (opt?.textContent || '').trim() || '9+ months until expiration';
  };

  function findNameEl(card) {
    return card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  }

  function findPriceEl(card) {
    const cands = card.querySelectorAll(
      '[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]'
    );
    for (const el of cands) {
      if (/\$\s*\d/.test((el.textContent || '').trim())) return el;
    }
    return cands[0] || null;
  }

  // Keep styling; avoid concatenation like "$8.00" + "5.00"
  function setPriceKeepingStyle(el, value) {
    if (!el) return;
    el.textContent = fmt(value);
    try {
      const cls = el.classList;
      const hasGreen = Array.from(cls).some(c => c === 'text-success' || c.startsWith('text-green'));
      if (!hasGreen) cls.add('text-green-600', 'font-semibold');
    } catch {}
  }

  // Build lookup from sheet
  function buildMap(rows) {
    const map = new Map();
    rows.forEach(r => {
      const raw =
        r.product_name ?? r['Product Name'] ?? r.name ?? r.Name ?? r.product ?? r.Product ?? r.title ?? r.Title;
      const key = norm(raw);
      if (!key) return;
      map.set(key, {
        key,
        w: words(key),
        n: nums(key),
        price_9plus: toNum(r.price_9plus ?? r['price_9+'] ?? r['9+'] ?? r['9_plus'] ?? r['9 mo']),
        price_7to8:  toNum(r.price_7to8  ?? r['7-8']     ?? r['7_to_8'] ?? r['7-8 mo']),
        price_6:     toNum(r.price_6     ?? r['6']       ?? r['6 mo']   ?? r['6_months']),
      });
    });
    if (DEBUG) {
      console.log('[price-sync] sheet rows parsed:', rows.length, 'map size:', map.size);
      window.__priceSyncMapKeys = [...map.keys()];
    }
    return map;
  }

  // Robust matcher: prefer number matches + containment + shared keywords
  function bestRowForTitle(map, title) {
    const titleNorm = norm(title);
    const tw = words(titleNorm);
    const tn = nums(titleNorm);

    let best = null;
    let bestScore = -1;

    for (const row of map.values()) {
      let score = 0;

      // strong: any shared number (50, 100, 7, etc.)
      const hasNum = row.n.some(n => tn.includes(n));
      if (hasNum) score += 5;

      // medium: contains / contained-by
      if (titleNorm.includes(row.key) || row.key.includes(titleNorm)) score += 3;

      // light: shared words
      const shared = row.w.filter(w => tw.includes(w)).length;
      score += Math.min(shared, 5); // cap to avoid runaway

      if (score > bestScore) {
        best = row;
        bestScore = score;
      }
    }

    // Require at least *some* confidence:
    // - any number match, OR
    // - containment and ≥2 shared words.
    if (!best) return null;
    const confident =
      best.n.some(n => nums(titleNorm).includes(n)) ||
      ((titleNorm.includes(best.key) || best.key.includes(titleNorm)) && best.w.filter(w => words(titleNorm).includes(w)).length >= 2);

    return confident ? best : null;
  }

  function rowForCard(map, card) {
    const nameEl = findNameEl(card);
    if (!nameEl) return null;
    const visible = (nameEl.textContent || '').trim();

    // 1) alias → exact
    const alias = ALIAS[visible];
    if (alias) {
      const r = map.get(norm(alias));
      if (r) return r;
    }
    // 2) exact
    const exact = map.get(norm(visible));
    if (exact) return exact;

    // 3) robust best-match
    return bestRowForTitle(map, visible);
  }

  function applyOne(map, card) {
    const priceEl = findPriceEl(card);
    if (!priceEl) return false;

    const sel = card.querySelector('select');
    const col = EXP_MAP[labelFor(sel)] || 'price_9plus';

    const row = rowForCard(map, card);
    if (!row) {
      card.dataset.priceSyncMissing = '1';
      return false;
    }

    const val = row[col] ?? row.price_9plus;
    if (val == null) return false;

    setPriceKeepingStyle(priceEl, val);

    if (sel && !sel.dataset.boundPriceSync) {
      sel.addEventListener('change', () => applyOne(map, card));
      sel.dataset.boundPriceSync = '1';
    }
    return true;
  }

  function findAllCards() {
    const btns = [...document.querySelectorAll('button')].filter(b =>
      /add to sale/i.test(b.textContent || '')
    );
    const cards = [];
    for (const btn of btns) {
      const root =
        btn.closest('[data-product-card], .product-card, .bg-white, .card') ||
        btn.parentElement;
      if (root && !cards.includes(root)) cards.push(root);
    }
    return cards;
  }

  function applyAll(map) {
    const cards = findAllCards();
    let changed = 0;
    const missing = [];
    for (const card of cards) {
      const ok = applyOne(map, card);
      if (ok) changed++;
      if (card.dataset.priceSyncMissing === '1') {
        const t = findNameEl(card)?.textContent?.trim();
        if (t) missing.push(t);
        delete card.dataset.priceSyncMissing;
      }
    }
    if (DEBUG) {
      console.log('[price-sync] applied to', cards.length, 'cards; changed', changed, 'prices');
      if (missing.length) console.warn('[price-sync] could not match titles (add ALIAS if needed):', missing);
    }
  }

  function hydrate(rows) {
    const map = buildMap(rows);
    applyAll(map);

    // react to SPA/tab/infinite-list changes
    const mo = new MutationObserver(() => applyAll(map));
    mo.observe(document.body, { childList: true, subtree: true });

    // a few retries to catch late content
    let tries = 0;
    const max = 6;
    const tick = () => { applyAll(map); if (++tries < max) setTimeout(tick, 1200); };
    tick();

    window.priceSyncForce = () => applyAll(map);
  }

  function startOnceCardsExist() {
    let checks = 0, maxChecks = 30;
    const wait = () => {
      if (findAllCards().length > 0) {
        if (DEBUG) console.log('[price-sync] cards detected; starting CSV load');
        loadCSV();
      } else if (checks++ < maxChecks) {
        setTimeout(wait, 500);
      } else {
        console.warn('[price-sync] no cards detected; gave up waiting');
      }
    };
    wait();
  }

  function loadCSV() {
    const run = () => {
      Papa.parse(CSV_URL + '&cb=' + Date.now(), {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: res => hydrate(res.data),
        error: err => console.error('[price-sync] CSV load error', err),
      });
    };
    if (typeof Papa === 'undefined') {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
      s.onload = run;
      s.onerror = () => console.error('[price-sync] Failed to load PapaParse');
      document.head.appendChild(s);
    } else {
      run();
    }
  }

  if (DEBUG) console.log('[price-sync] inline script loaded');
  startOnceCardsExist();
})();
</script>






</body>

</html>
