<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<!-- Price sync from Google Sheets (robust matching + safe replace) -->
<script>
(() => {
  const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';

  const EXP_MAP = {
    '9+ months until expiration': 'price_9plus',
    '9 months until expiration':  'price_9plus',
    '7-8 months until expiration': 'price_7to8',
    '6 months until expiration':   'price_6',
  };

  // If any card title doesn't match your sheet exactly, map it here:
  const ALIAS = {
    // 'MMT-242': 'MMT-242',
    // 'OneTouch Ultra 50 Ct.': 'OneTouch Ultra 50 Ct.',
  };

  // ---------- helpers ----------
  const norm = s => (s || '').toLowerCase().replace(/\s+/g, ' ').trim();
  const slug = s => (s || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g,'');
  const toNum = v => {
    const n = Number(String(v ?? '').replace(/[^\d.]/g, ''));
    return Number.isFinite(n) ? n : null;
  };
  const fmt = n => '$' + Number(n).toFixed(2);

  // Replace the first $â€¦ number inside el (or its children) without nuking classes
  function replaceCurrency(el, text){
    const stack = [el, ...el.querySelectorAll('*')];
    for (const node of stack) {
      const t = node.textContent || '';
      if (/\$\s*[\d,.]+/.test(t)) {
        node.textContent = t.replace(/\$\s*[\d,.]+/, text);
        try { node.classList.add('text-green-600','font-semibold'); } catch {}
        return true;
      }
    }
    // Fallback: set outer text (preserves parent classes but removes inner nodes)
    el.textContent = text;
    try { el.classList.add('text-green-600','font-semibold'); } catch {}
    return true;
  }

  function findNameEl(card){
    return card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  }
  function findPriceEl(card){
    const cands = card.querySelectorAll('[data-price], .price, .product-price, .price-value, .text-success, .text-green, [class*="text-green"], [class*="price"]');
    for (const el of cands) {
      if (/\$\s*\d/.test((el.textContent || '').trim())) return el;
    }
    return cands[0] || null;
  }
  function labelFor(sel){
    const opt = sel?.options?.[sel.selectedIndex];
    return (opt ? opt.textContent : '').trim() || '9+ months until expiration';
  }

  // Build sheet rows with precomputed tokens
  const STOP = new Set(['test','tests','strip','strips','meter','sensors','sensor','pack','pk','ct','count','mm','in','only','kit','cartridges','infusion','set','sets','box','sealed','big','100','50','25','10','5']); // tune as needed
  function tokenize(s){
    return norm(s).split(' ').filter(w => w && !STOP.has(w));
  }

  function buildIndex(rows){
    const list = [];
    const map = new Map(); // exact keys
    rows.forEach(r => {
      const productName = r.product_name ?? r.name ?? r.product ?? r.Product ?? r.Name;
      const key = r.product_key;
      const row = {
        product_name: productName || '',
        product_key: key || '',
        price_9plus: toNum(r.price_9plus ?? r['9+ months until expiration'] ?? r['9+'] ?? r['9_plus']),
        price_7to8:  toNum(r.price_7to8  ?? r['7-8 months until expiration'] ?? r['7-8']),
        price_6:     toNum(r.price_6     ?? r['6 months until expiration']   ?? r['6']),
      };
      const nName = norm(productName);
      const sKey  = slug(key);
      if (nName) map.set(`name::${nName}`, row);
      if (sKey)  map.set(`key::${sKey}`,  row);
      // for fuzzy matching
      row._tokens = tokenize(productName || key || '');
      list.push(row);
    });
    return {list, map};
  }

  // Fuzzy match by token overlap; return best scoring row (>= 1)
  function fuzzyMatch(index, title){
    const tks = tokenize(title);
    let best = null, bestScore = 0;
    for (const r of index.list) {
      let s = 0;
      for (const w of tks) if (r._tokens.includes(w)) s += 1;
      if (s > bestScore) { bestScore = s; best = r; }
    }
    return bestScore >= 1 ? best : null;
  }

  function findAllCards(){
    const btns = [...document.querySelectorAll('button')].filter(b => /add to sale/i.test(b.textContent || ''));
    const cards = [];
    for (const btn of btns) {
      let el = btn.closest('[data-product-card], .product-card, .card, .bg-white') || btn.parentElement;
      for (let i = 0; i < 8 && el; i++) {
        if (findNameEl(el) && findPriceEl(el) && el.querySelector('select')) break;
        el = el.parentElement;
      }
      if (el && !cards.includes(el)) cards.push(el);
    }
    return cards;
  }

  function resolveRow(index, visibleTitle){
    const aliased = ALIAS[visibleTitle] || visibleTitle;
    // exact by name
    const byName = index.map.get(`name::${norm(aliased)}`);
    if (byName) return byName;
    // exact by key (slug of visible title)
    const byKey = index.map.get(`key::${slug(aliased)}`);
    if (byKey) return byKey;
    // fuzzy fallback
    return fuzzyMatch(index, aliased);
  }

  function applyPriceToCard(index, card){
    const nameEl  = findNameEl(card);
    const priceEl = findPriceEl(card);
    const sel     = card.querySelector('select');
    if (!nameEl || !priceEl || !sel) return false;

    const label = labelFor(sel);
    const col   = EXP_MAP[label] || 'price_9plus';

    const title = (nameEl.textContent || '').trim();
    const row   = resolveRow(index, title);
    if (!row) return false;

    const val = row[col] ?? row.price_9plus;
    if (val == null) return false;

    replaceCurrency(priceEl, fmt(val));

    if (!sel.dataset.boundPriceSync) {
      sel.addEventListener('change', () => applyPriceToCard(index, card));
      sel.dataset.boundPriceSync = '1';
    }
    return true;
  }

  function hydrate(rows){
    const index = buildIndex(rows);
    const cards = findAllCards();
    let changed = 0;
    for (const c of cards) if (applyPriceToCard(index, c)) changed++;
    console.log('[price-sync] applied to', cards.length, 'cards; changed', changed, 'prices');

    const mo = new MutationObserver(() => {
      let ch = 0;
      for (const c of findAllCards()) if (applyPriceToCard(index, c)) ch++;
      if (ch) console.log('[price-sync] changed', ch, 'prices (mutation)');
    });
    mo.observe(document.body, { childList:true, subtree:true });
  }

  function start(){
    function run(){
      Papa.parse(CSV_URL + '&cb=' + Date.now(), {
        download:true, header:true, skipEmptyLines:true,
        complete: res => hydrate(res.data),
        error: err => console.error('[price-sync] CSV load error', err),
      });
    }
    if (typeof Papa === 'undefined') {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
      s.onload = run;
      s.onerror = () => console.error('[price-sync] Failed to load PapaParse');
      document.head.appendChild(s);
    } else run();
  }

  console.log('[price-sync] inline script loaded');
  start();
})();
</script>






</body>

</html>
