<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<!-- Price sync from Google Sheets (fuzzy match, SPA-safe, keeps green styling) -->
<script>
(() => {
  // Run once guard
  if (window.__PRICE_SYNC_RUNNING__) return;
  window.__PRICE_SYNC_RUNNING__ = true;

  const CSV_URL =
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';
  const DEBUG = true;

  // Buckets: detect from option label (even if it also shows a price)
  const EXP_KEYS = [
    { test: /9\+|\b9\s*months?/i, col: 'p9'  },
    { test: /\b7\s*[-–]\s*8|\b7-8/i, col: 'p78' },
    { test: /\b6\s*months?/i,     col: 'p6'  }
  ];

  // Optional manual overrides: 'Card Title' : 'Sheet Name'
  const ALIAS = {
    // 'MMT-242': 'MMT 242',
  };

  // ---------- helpers ----------
  const norm = s =>
    (s || '')
      .toLowerCase()
      .replace(/™|®/g, '')
      .replace(/[^a-z0-9]+/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

  const toNum = v => {
    const n = Number(String(v ?? '').replace(/[^\d.]/g, ''));
    return Number.isFinite(n) ? n : null;
  };

  const fmt = n => '$' + Number(n).toFixed(2);

  function findNameEl(card) {
    return card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  }
  function findPriceEl(card) {
    const cands = card.querySelectorAll(
      '[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]'
    );
    for (const el of cands) if (/\$\s*\d/.test((el.textContent || '').trim())) return el;
    return cands[0] || null;
  }
  function findSelect(card) { return card.querySelector('select'); }

  function pickColFromLabelText(txt) {
    const t = (txt || '').toString();
    for (const k of EXP_KEYS) if (k.test.test(t)) return k.col;
    return 'p9';
  }

  // ✅ keep your styling and avoid "$8.00" + "5.00" concatenation
  function setPriceKeepingStyle(el, value) {
    if (!el) return;
    el.textContent = fmt(value);
    try {
      const cls = el.classList;
      const hasGreen = Array.from(cls).some(c => c === 'text-success' || c.startsWith('text-green'));
      if (!hasGreen) cls.add('text-green-600', 'font-semibold');
    } catch {}
  }

  function findAllCards() {
    const btns = [...document.querySelectorAll('button')].filter(b =>
      /add to sale/i.test(b.textContent || '')
    );
    const cards = [];
    for (const b of btns) {
      let root = b.closest('[data-product-card], .product-card, .bg-white, .card') || b.parentElement;
      // Climb a bit if needed until name + (price or green class) exist
      for (let i = 0; i < 8 && root; i++) {
        if (findNameEl(root) && (findPriceEl(root) || root.querySelector('[class*="text-green"]'))) break;
        root = root.parentElement;
      }
      if (root && !cards.includes(root)) cards.push(root);
    }
    return cards;
  }

  // Build an index from YOUR exact sheet headers
  function buildIndex(rows) {
    const index = [];
    for (const r of rows) {
      const name =
        r.product_name || r.Product_Name || r.name || r.Name || r.product || r.Product;
      if (!name) continue;
      const key = norm(name);
      index.push({
        key,
        tokens: new Set(key.split(' ')),
        row: {
          p9:  toNum(
                r['9+ months until expiration'] ??
                r['9 months until expiration'] ??
                r.price_9plus ?? r['9+'] ?? r['9_plus'] ?? r['9 mo']
              ),
          p78: toNum(
                r['7-8 months until expiration'] ??
                r.price_7to8 ?? r['7-8'] ?? r['7_to_8'] ?? r['7-8 mo']
              ),
          p6:  toNum(
                r['6 months until expiration'] ??
                r.price_6 ?? r['6'] ?? r['6 mo'] ?? r['6_months']
              ),
        }
      });
    }
    return index;
  }

  // Fuzzy match: token overlap (numbers get a bit more weight)
  function resolveRow(index, visibleName) {
    const alias = ALIAS[visibleName] || visibleName;
    const key = norm(alias);
    if (!key) return null;

    // exact first
    const exact = index.find(e => e.key === key);
    if (exact) return exact.row;

    const tokens = key.split(' ').filter(Boolean);
    let top = null, topScore = -1;
    for (const e of index) {
      let s = 0;
      for (const t of tokens) {
        if (e.tokens.has(t)) {
          s += 1;
          if (/^\d+$/.test(t)) s += 0.75;   // numbers like 50 / 100 / 6 / 7-8
          if (t.length >= 5) s += 0.25;     // longer word = more specific
        }
      }
      if (s > topScore) { topScore = s; top = e; }
    }
    return topScore >= 2 ? top.row : null;  // modest confidence threshold
  }

  function applyToCard(index, card) {
    const nameEl  = findNameEl(card);
    const priceEl = findPriceEl(card);
    if (!nameEl || !priceEl) return false;

    const sel      = findSelect(card);
    const labelTxt = sel?.options?.[sel.selectedIndex]?.textContent || '';
    const col      = pickColFromLabelText(labelTxt);

    const row = resolveRow(index, (nameEl.textContent || '').trim());
    if (!row) { card.dataset.priceSyncMissing = '1'; return false; }

    const val = row[col] ?? row.p9;
    if (val == null) return false;

    setPriceKeepingStyle(priceEl, val);

    if (sel && !sel.dataset.boundPriceSync) {
      sel.addEventListener('change', () => applyToCard(index, card));
      sel.dataset.boundPriceSync = '1';
    }
    return true;
  }

  // Debounced apply to avoid noisy loops in prod
  let applyQueued = false, applyTimer = null, currentIndex = null;
  function queueApplyAll() {
    if (applyQueued) return;
    applyQueued = true;
    applyTimer = setTimeout(() => {
      applyQueued = false;
      if (!currentIndex) return;
      const cards = findAllCards();
      let changed = 0;
      for (const c of cards) if (applyToCard(currentIndex, c)) changed++;
      if (DEBUG) console.log('[price-sync] applied to', cards.length, 'cards; changed', changed, 'prices');
    }, 150);
  }

  function runWith(rows) {
    currentIndex = buildIndex(rows);
    // First pass
    queueApplyAll();

    // Observe SPA/tab/infinite-list changes (childList only; not characterData)
    const mo = new MutationObserver(queueApplyAll);
    mo.observe(document.body, { childList: true, subtree: true });

    // A few retries to catch late content
    let tries = 0;
    const max = 6;
    (function tick() {
      queueApplyAll();
      if (++tries < max) setTimeout(tick, 800);
    })();
  }

  function fetchCSVThen(cb) {
    Papa.parse(CSV_URL + '&cb=' + Date.now(), {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: res => cb(res.data),
      error: err => console.error('[price-sync] CSV load error', err),
    });
  }

  function start() {
    // Wait for cards to exist so prod doesn’t blow up if SPA is slow
    let checks = 0, max = 40;
    (function waitForCards() {
      if (findAllCards().length > 0) {
        if (DEBUG) console.log('[price-sync] cards detected; starting CSV load');
        fetchCSVThen(runWith);
      } else if (checks++ < max) {
        setTimeout(waitForCards, 300);
      } else {
        // Still load; the observer + retries will catch late content
        if (DEBUG) console.log('[price-sync] no cards yet; loading CSV anyway');
        fetchCSVThen(runWith);
      }
    })();
  }

  // Load PapaParse if needed
  if (typeof Papa === 'undefined') {
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
    s.onload = start;
    s.onerror = () => console.error('[price-sync] Failed to load PapaParse');
    document.head.appendChild(s);
  } else {
    start();
  }

  if (DEBUG) console.log('[price-sync] inline script loaded');
})();
</script>







</body>

</html>
