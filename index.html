<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<!-- Price sync from Google Sheets (fuzzy name match + preserves green styling) -->
<script id="price-sync-google">
(() => {
  console.log('[price-sync] inline script loaded');

  const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';

  const EXP_MAP = {
    '9+ months until expiration': 'price_9plus',
    '9 months until expiration':  'price_9plus',
    '7-8 months until expiration': 'price_7to8',
    '6 months until expiration':   'price_6',
  };

  // If a card title differs from the sheet’s “name”, map it here:
  const ALIAS = {
    // 'Card Title as shown on site': 'Exact name in Google Sheet',
  };

  // -------- helpers --------
  const norm = s => (s || '').toLowerCase().replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
  const toNum = v => {
    const n = Number(String(v ?? '').replace(/[^\d.]/g,''));
    return Number.isFinite(n) ? n : null;
  };
  const fmt = n => '$' + Number(n).toFixed(2);

  function findNameEl(card){
    return card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  }

  function findPriceContainer(card){
    const cands = card.querySelectorAll(
      '[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]'
    );
    for (const el of cands) if (/\d/.test(el.textContent || '')) return el;
    for (const el of card.querySelectorAll('*')){
      if (/^\$?\d+(\.\d{1,2})?$/.test((el.textContent || '').trim())) return el;
    }
    return null;
  }

  function findNumberNode(el){
    const exact = [...el.querySelectorAll('span, strong, b, i, em')]
      .find(n => /^\$?\d+(\.\d{1,2})?$/.test((n.textContent || '').trim()));
    if (exact) return exact;
    const tn = [...(el.childNodes || [])].find(n => n.nodeType===3 && /\d/.test(n.textContent || ''));
    return tn || el;
  }

  function setPrice(el, value){
    if (!el) return;
    const txt = fmt(value);
    const node = findNumberNode(el);
    node.textContent = txt;
    try {
      const cls = (node===el ? el : el).classList;
      const hasGreen = [...cls].some(c => c==='text-success' || c.startsWith('text-green'));
      if (!hasGreen) cls.add('text-green-600','font-semibold');
    } catch {}
  }

  function dropdownLabel(sel){
    const opt = sel?.options?.[sel.selectedIndex];
    return (opt ? opt.textContent : '').trim() || '9+ months until expiration';
  }

  function findAllCards(){
    const btns = [...document.querySelectorAll('button')].filter(b =>
      /add to sale/i.test(b.textContent || '')
    );
    const cards = btns.map(b =>
      b.closest('[data-product-card], .product-card, .bg-white, .card, .rounded, .border') || b.parentElement
    ).filter(Boolean);
    return [...new Set(cards)];
  }

  function buildMap(rows){
    const map = new Map();
    const keys = [];
    rows.forEach(r => {
      const k = norm(r.name || r.Name || r.product || r.Product);
      if (!k) return;
      map.set(k, {
        rawName: (r.name || r.Name || r.product || r.Product || '').trim(),
        price_9plus: toNum(r.price_9plus ?? r['9+'] ?? r['9_plus'] ?? r['9 mo']),
        price_7to8:  toNum(r.price_7to8  ?? r['7-8'] ?? r['7_to_8'] ?? r['7-8 mo']),
        price_6:     toNum(r.price_6     ?? r['6']   ?? r['6 mo']),
      });
      keys.push(k);
    });
    return { map, keys };
  }

  // Very simple fuzzy: token overlap + number matches; ignores tiny stop-words
  const STOP = new Set(['ct','box','pack','pk','only','kit','sets','set','and','or','of','the','mm','in']);
  function tokens(s){
    return norm(s).split(' ').filter(w => w.length>1 && !STOP.has(w));
  }
  function numbers(s){
    return (s.match(/\d+/g) || []);
  }
  function pickBestKey(visibleName, keys){
    const tw = tokens(visibleName);
    const tn = new Set(numbers(visibleName));
    let best = null, bestScore = 0;
    for (const k of keys){
      const kw = tokens(k);
      const kn = new Set(numbers(k));
      let score = 0;
      for (const w of tw) if (kw.includes(w)) score += 1;
      for (const n of tn) if (kn.has(n)) score += 2; // weight numbers
      if (score > bestScore){
        bestScore = score; best = k;
      }
    }
    // require a minimum to avoid bad matches
    return bestScore >= 2 ? best : null;
  }

  function findRowForCard(index, card){
    const nameEl = findNameEl(card);
    if (!nameEl) return null;
    const visible = (nameEl.textContent || '').trim();
    const alias = ALIAS[visible] || visible;

    const exact = index.map.get(norm(alias));
    if (exact) return exact;

    const fuzzyKey = pickBestKey(visible, index.keys);
    return fuzzyKey ? index.map.get(fuzzyKey) : null;
  }

  function applyPriceToCard(index, card){
    const sel = card.querySelector('select');
    const col = EXP_MAP[dropdownLabel(sel)] || 'price_9plus';
    const row = findRowForCard(index, card);
    if (!row) { card.dataset.priceSyncMissing = '1'; return false; }

    const val = row[col] ?? row.price_9plus;
    if (val == null) return false;

    const priceEl = findPriceContainer(card);
    if (!priceEl) return false;

    const current = toNum((priceEl.textContent || '').trim());
    if (current === val) return false;

    setPrice(priceEl, val);

    if (sel && !sel.dataset.bound){
      sel.addEventListener('change', () => applyPriceToCard(index, card));
      sel.dataset.bound = '1';
    }
    return true;
  }

  function hydrate(rows){
    const index = buildMap(rows);

    const applyAll = () => {
      const cards = findAllCards();
      let changed = 0, missing = [];
      cards.forEach(c => {
        const ok = applyPriceToCard(index, c);
        if (!ok && !findRowForCard(index, c)) {
          const nameEl = findNameEl(c);
          missing.push((nameEl?.textContent || '').trim());
        }
      });
      console.log('[price-sync] applied to', cards.length, 'cards');
      console.log('[price-sync] changed', changed = document.querySelectorAll('[data-price-sync-missing]').length ? (cards.length - document.querySelectorAll('[data-price-sync-missing]').length) : cards.length, 'prices');
      if (missing.length){
        console.log('[price-sync] could not match these titles (add to ALIAS if needed):', [...new Set(missing)].slice(0,8));
      }
    };

    // run now + for a handful of frames while SPA finishes
    applyAll();
    let tries = 30;
    const tick = () => { applyAll(); if (--tries > 0) requestAnimationFrame(tick); };
    requestAnimationFrame(tick);

    // also watch for DOM changes (tab switches, lazy lists)
    const mo = new MutationObserver(applyAll);
    mo.observe(document.body, { childList:true, subtree:true });

    // Expose a tiny debug helper
    window.__priceSyncDebug = () => {
      const cards = findAllCards();
      return cards.slice(0,5).map(c => {
        const name = (findNameEl(c)?.textContent || '').trim();
        const fuzzy = pickBestKey(name, index.keys);
        return { cardTitle: name, matchedSheetName: fuzzy || '(none)' };
      });
    };
  }

  function start(){
    function run(){
      Papa.parse(CSV_URL + '&cb=' + Date.now(), {
        download:true, header:true, skipEmptyLines:true,
        complete: res => hydrate(res.data),
        error: err => console.error('[price-sync] CSV load error', err),
      });
    }
    if (typeof Papa === 'undefined'){
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
      s.onload = run;
      s.onerror = () => console.error('[price-sync] Failed to load PapaParse');
      document.head.appendChild(s);
    } else run();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', start, { once:true });
  } else {
    start();
  }
})();
</script>





</body>

</html>
