<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<script>
 (() => {
  const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';

  // Labels exactly as they appear in the dropdowns
  const LAB_9  = '9+ months until expiration';
  const LAB_78 = '7-8 months until expiration';
  const LAB_6  = '6 months until expiration';

  // The white “card” container
  const CARD_SEL = '.bg-white.rounded-lg, .bg-white.rounded-md, .product-card, [data-product-card], .bg-white';

  // Helpers
  const money = n => '$' + Number(n).toFixed(2);
  const num = v => { const m = String(v ?? '').match(/[\d.]+/); return m ? Number(m[0]) : null; };
  const norm = s => (s||'')
    .toLowerCase()
    .replace(/&/g,' and ')
    .replace(/[^a-z0-9\s]/g,' ')
    .replace(/\s+/g,' ')
    .trim();

  // Words that don’t help matching product names
  const STOP = new Set(['test','tests','strip','strips','meter','sensors','sensor','pack','pk','box','sealed','ct','count','mm','in','only','kit','big','big','cartridges','infusion','sets','set','reader','freestyle','accu','chek','accu chek','one','touch','onetouch']);

  const toWords = s => norm(s).split(' ').filter(w => w && !STOP.has(w));

  // Find all product “cards”
  function findCards(){
    const addBtns = [...document.querySelectorAll('button')].filter(b => /add to sale/i.test(b.textContent||''));
    const roots = [...new Set(addBtns.map(btn => {
      let n = btn.parentElement;
      for (let i=0; i<12 && n; i++){
        if (n.matches?.(CARD_SEL)) return n;
        n = n.parentElement;
      }
      return btn.closest(CARD_SEL) || btn.parentElement;
    }))];

    return roots.map(root => {
      const sel = root.querySelector('select');
      // title detection: prefer headings, else first bold/medium-ish title above the select
      let nameEl = root.querySelector('h1,h2,h3,h4,.card-title,.product-name');
      if (!nameEl && sel){
        let n = sel;
        while (n && n !== root) {
          const p = n.previousElementSibling;
          if (p && p.textContent?.trim() && p.textContent.trim().length <= 100) { nameEl = p; break; }
          n = n.parentElement;
        }
      }
      // price: first element that looks like $##
      let priceEl = [...root.querySelectorAll('*')].find(n => /^\s*\$\d/.test(n.textContent||''));
      return { root, sel, priceEl, nameEl };
    });
  }

  function run(rows){
    // Build row list + quick exact map
    const rowList = rows.map(r => ({
      raw: r,
      name: r.product_name || r.Product || r.name || '',
      p9:  num(r[LAB_9]),
      p78: num(r[LAB_78]),
      p6:  num(r[LAB_6]),
      words: toWords(r.product_name || r.Product || r.name || '')
    })).filter(r => r.name);

    const exactMap = new Map(rowList.map(r => [norm(r.name), r]));

    function pickRow(name){
      const n = norm(name);
      if (!n) return null;
      if (exactMap.has(n)) return exactMap.get(n);

      // fuzzy: by word overlap (ignoring STOP words)
      const nameWords = toWords(name);
      let best = null, bestScore = 0;
      for (const r of rowList){
        let score = 0;
        for (const w of nameWords) if (r.words.includes(w)) score++;
        // reward length proximity (avoid picking “50 Ct” vs “100 Ct” accidentally)
        if (/\b50\b/.test(n) && /\b50\b/.test(norm(r.name))) score += 0.5;
        if (/\b100\b/.test(n) && /\b100\b/.test(norm(r.name))) score += 0.5;
        if (score > bestScore) { bestScore = score; best = r; }
      }
      return bestScore >= 1 ? best : null; // require at least one useful word in common
    }

    const cards = findCards();
    let changed = 0;
    cards.forEach((c, i) => {
      const title = (c.nameEl?.textContent || '').trim();
      const row = pickRow(title);
      const selLabel = c.sel ? c.sel.options[c.sel.selectedIndex].text.replace(/\s*-\s*\$\d+$/,'').trim() : LAB_9;

      const val = row
        ? (selLabel === LAB_9 ? row.p9 : selLabel === LAB_78 ? row.p78 : selLabel === LAB_6 ? row.p6 : null)
        : null;

      console.log({i:i+1, title, picked: row?.name || null, selLabel, val, hasPriceEl: !!c.priceEl});

      if (row && c.priceEl && val != null){
        c.priceEl.textContent = money(val);
        changed++;
        // bind once so changing the dropdown re-applies correct price
        if (c.sel && !c.sel.dataset.bound){
          c.sel.addEventListener('change', () => run(rows));
          c.sel.dataset.bound = '1';
        }
      }
    });

    console.log('[price-sync] changed', changed, 'cards');
  }

  function load(){
    if (window.Papa){
      Papa.parse(CSV_URL + '&cb=' + Date.now(), {
        download: true, header: true, skipEmptyLines: true,
        complete: res => run(res.data),
        error: err => console.error('[price-sync] CSV load error', err)
      });
    } else {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
      s.onload = load;
      s.onerror = () => console.error('[price-sync] failed to load PapaParse');
      document.head.appendChild(s);
    }
  }

  load();
})();

</script>








</body>

</html>
