<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script type="module" crossorigin src="./assets/index-BGoGBgGF.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-BQIE1QGu.css">
</head>

<body>
  <div id="root"></div>
<!-- Price Sync LITE (with logs): updates the green on-card price from Google Sheets -->
<script>
(() => {
  // Prevent double-run
  if (window.__PS_LITE__) return; window.__PS_LITE__ = true;
  console.log('[ps-lite] inline script loaded');

  // Your published CSV
  const CSV_URL =
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';

  // Map dropdown text -> sheet columns
  const EXP_KEYS = [
    { test: /9\+|\b9\s*months?/i, col: 'p9'  },
    { test: /\b7\s*[-–]?\s*8|\b7-8/i,        col: 'p78' },
    { test: /\b6\s*months?/i,               col: 'p6'  }
  ];

  // Optional name fallbacks if a visible card title differs from sheet name
  const ALIAS = {
    // 'MMT-242': 'MMT 242',
  };

  // ---------- helpers ----------
  const norm = s => (s||'')
    .toLowerCase().replace(/™|®/g,'')
    .replace(/[^a-z0-9]+/g,' ')
    .replace(/\s+/g,' ')
    .trim();

  const toNum = v => {
    const n = Number(String(v ?? '').replace(/[^\d.]/g,''));
    return Number.isFinite(n) ? n : null;
  };

  const fmt = n => '$' + Number(n).toFixed(2);

  const pickCol = label => {
    const t = (label||'').toString();
    for (const k of EXP_KEYS) if (k.test.test(t)) return k.col;
    return 'p9';
  };

  function findNameEl(card){
    return card.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  }
  function findPriceEl(card){
    const cands = card.querySelectorAll(
      '[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]'
    );
    for (const el of cands) if (/\$\s*\d/.test((el.textContent||'').trim())) return el;
    return cands[0] || null;
  }
  const findSelect = c => c.querySelector('select');

  function setPriceKeepingStyle(el, value){
    if (!el) return;
    el.textContent = fmt(value);
    try {
      const cls = el.classList;
      const hasGreen = Array.from(cls).some(c => c === 'text-success' || c.startsWith('text-green'));
      if (!hasGreen) cls.add('text-green-600', 'font-semibold');
    } catch {}
  }

  function findAllCards(){
    const btns = [...document.querySelectorAll('button')].filter(b => /add to sale/i.test(b.textContent||''));
    const cards = [];
    for (const b of btns){
      let root = b.closest('[data-product-card], .product-card, .bg-white, .card') || b.parentElement;
      for (let i=0;i<8 && root;i++){
        if (findNameEl(root) && (findPriceEl(root) || root.querySelector('[class*="text-green"]'))) break;
        root = root.parentElement;
      }
      if (root && !cards.includes(root)) cards.push(root);
    }
    return cards;
  }

  // ---------- build sheet index ----------
  let PRICE_INDEX = []; // [{key,tokens,row:{p9,p78,p6}}]
  function buildIndex(rows){
    const idx = [];
    for (const r of rows){
      const name = r.product_name || r.Product_Name || r.name || r.Name || r.product || r.Product;
      if (!name) continue;
      const key = norm(name);
      idx.push({
        key,
        tokens: new Set(key.split(' ')),
        row: {
          p9:  toNum(r['9+ months until expiration'] ?? r['9 months until expiration'] ?? r.price_9plus ?? r['9+'] ?? r['9_plus'] ?? r['9 mo']),
          p78: toNum(r['7-8 months until expiration'] ?? r.price_7to8 ?? r['7-8'] ?? r['7_to_8'] ?? r['7-8 mo']),
          p6:  toNum(r['6 months until expiration']   ?? r.price_6     ?? r['6']   ?? r['6 mo']     ?? r['6_months']),
        }
      });
    }
    return idx;
  }

  function resolveRow(visibleName){
    const alias = ALIAS[visibleName] || visibleName;
    const key = norm(alias);
    if (!key) return null;

    const exact = PRICE_INDEX.find(e => e.key === key);
    if (exact) return exact.row;

    const tokens = key.split(' ').filter(Boolean);
    let best=null, score=-1;
    for (const e of PRICE_INDEX){
      let s=0;
      for (const t of tokens){
        if (e.tokens.has(t)){
          s += 1;
          if (/^\d+$/.test(t)) s += 0.75;
          if (t.length >= 5)  s += 0.25;
        }
      }
      if (s>score){ score=s; best=e; }
    }
    return score >= 2 ? best.row : null;
  }

  function applyToCard(card){
    const nameEl  = findNameEl(card);
    const priceEl = findPriceEl(card);
    if (!nameEl || !priceEl) return false;

    const sel = findSelect(card);
    const label = sel?.options?.[sel.selectedIndex]?.textContent || '9+ months until expiration';

    const row = resolveRow((nameEl.textContent||'').trim());
    if (!row) return false;

    const col = pickCol(label);
    const val = row[col] ?? row.p9;
    if (val == null) return false;

    // prevent redundant writes
    const key = (row.key || nameEl.textContent || '') + '|' + col + '|' + val;
    if (card.dataset.psLiteKey === key) return false;

    setPriceKeepingStyle(priceEl, val);
    card.dataset.psLiteKey = key;
    return true;
  }

  // Throttled apply
  let pending = false;
  function applyAllThrottled(tag=''){
    if (pending) return;
    pending = true;
    setTimeout(() => {
      pending = false;
      const cards = findAllCards();
      let changed = 0;
      for (const c of cards) if (applyToCard(c)) changed++;
      console.log(`[ps-lite] applied to ${cards.length} cards; changed ${changed} prices` + (tag?` (${tag})`:''));      
    }, 120);
  }

  function startSync(){
    // Wait for cards, then fetch CSV
    let tries=0, max=40;
    (function waitForCards(){
      const count = findAllCards().length;
      if (count){
        console.log('[ps-lite] cards detected:', count, '— starting CSV load');
        Papa.parse(CSV_URL + '&cb=' + Date.now(), {
          download:true, header:true, skipEmptyLines:true,
          complete: res => {
            PRICE_INDEX = buildIndex(res.data);
            console.log('[ps-lite] sheet rows parsed:', res.data.length);
            applyAllThrottled('initial');
            // Observe a bit for SPA updates
            const root = document.querySelector('#root') || document.body;
            let passes=0; const mo = new MutationObserver(() => {
              applyAllThrottled('mutation');
              if (++passes > 15) { mo.disconnect(); console.log('[ps-lite] observer disconnected'); }
            });
            mo.observe(root, { childList:true, subtree:true });
          },
          error: err => console.error('[ps-lite] CSV load error', err),
        });
      } else if (++tries < max){
        setTimeout(waitForCards, 250);
      } else {
        console.warn('[ps-lite] no cards detected — giving up');
      }
    })();
  }

  // Load PapaParse then start
  if (typeof Papa === 'undefined'){
    const s=document.createElement('script');
    s.src='https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
    s.onload=startSync;
    s.onerror=()=>console.error('[ps-lite] Failed to load PapaParse');
    document.head.appendChild(s);
  } else {
    startSync();
  }
})();
</script>

<script>
(() => {
  if (window.__PS_SYNC_V75__) return; window.__PS_SYNC_V75__ = true;
  console.log('[ps-sync v7.5] init');

  const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyuGyVeB6_EMydb8kxP0wiZXyxVFsaaNiM0w6yMj5w4tGomMNWn6glhqlfDJd1laA583L1EL91ZA3/pub?output=csv';

  // ---------- utils ----------
  const fmt   = n => '$' + Number(n).toFixed(2);
  const toNum = v => { const n = Number(String(v ?? '').replace(/[^\d.]/g,'')); return Number.isFinite(n)?n:null; };
  const normBase = s => (s||'').toLowerCase()
    .replace(/™|®/g,'')
    .replace(/\b(count|counts|ct|cts)\b/g,'ct')
    .replace(/[^a-z0-9]+/g,' ')
    .replace(/\s+/g,' ')
    .trim();

  const STOP = new Set(['test','tests','strip','strips','meter','sensors','sensor','pack','pk','box','only','mm','nm','kit','guide','brand','mfr','mail','order','and','or','for','with','one','by']);

  const tokensOf = s => {
    const t = normBase(s).split(' ').filter(Boolean);
    // unique, drop stopwords but keep numbers and long tokens
    const u = [];
    const seen = new Set();
    for (const w of t){
      if (seen.has(w)) continue;
      seen.add(w);
      if (/^\d+$/.test(w) || w.length >= 3){
        if (!STOP.has(w)) u.push(w);
      }
    }
    return u;
  };

  const baseLabel = t => String(t||'').replace(/\s*[-–]?\s*\$[\d.,]+$/,'').trim();
  const labelToCol = label =>
    /\b6\s*months?/i.test(label) ? 'p6'
    : /\b7\s*[-–]?\s*8|\b7-8/i.test(label) ? 'p78'
    : 'p9';

  const looksLikeNoise = t => /don.?t see|your product|text us|meters|lancets|medtronic/i.test(t);

  const ALIAS = {
    // Add any stubborn titles here if needed:
    // 'OneTouch Ultra 50 Ct.' : 'OneTouch Ultra 50 Ct',
  };

  // ---------- sheet index ----------
  let INDEX = null; // Array<{key, toks:Set, row:{p9,p78,p6}}>
  function buildIndex(rows){
    const idx = [];
    for (const r of rows){
      const name = r.product_name || r.Product_Name || r.name || r.Name || r.product || r.Product;
      if (!name) continue;
      const key = normBase(name);
      idx.push({
        key,
        toks: new Set(tokensOf(name)),
        row: {
          p9 : toNum(r['9+ months until expiration'] ?? r['9 months until expiration'] ?? r.price_9plus ?? r['9+'] ?? r['9_plus'] ?? r['9 mo']),
          p78: toNum(r['7-8 months until expiration'] ?? r.price_7to8 ?? r['7-8'] ?? r['7_to_8'] ?? r['7-8 mo']),
          p6 : toNum(r['6 months until expiration']   ?? r.price_6     ?? r['6']   ?? r['6 mo']),
        }
      });
    }
    console.log('[ps-sync v7.5] sheet rows indexed:', idx.length);
    return idx;
  }

  // ---------- DOM helpers ----------
  const nameEl  = c => c.querySelector('[data-product-name], .product-name, .card-title, h3, h4, .title');
  const priceEl = c => {
    const cands = c.querySelectorAll('[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]');
    for (const el of cands) if (/\$\s*\d/.test((el.textContent||'').trim())) return el;
    return cands[0] || null;
  };

  function addCardRoot(set, node){
    let r = node.closest('[data-product-card], .product-card, .bg-white, .card') || node.parentElement;
    for (let i=0;i<8 && r;i++){
      if (nameEl(r) && (priceEl(r) || r.querySelector('select'))) break;
      r = r.parentElement;
    }
    if (r) set.add(r);
  }

  function findCards(){
    const roots = new Set();
    const btns   = [...document.querySelectorAll('button')].filter(b => /add to sale/i.test(b.textContent||''));
    const sels   = [...document.querySelectorAll('select')];
    const greens = [...document.querySelectorAll('[data-price], .price, .product-price, .price-value, .text-success, .text-green-600, .text-green-700, [class*="text-green"]')];

    btns.forEach(n=>addCardRoot(roots,n));
    sels.forEach(n=>addCardRoot(roots,n));
    greens.forEach(n=>addCardRoot(roots,n));

    const cards = [...roots].filter(r => {
      const title = (nameEl(r)?.textContent || '').trim();
      return title && !looksLikeNoise(title);
    });

    console.log('[ps-sync v7.5] probe buttons='+btns.length+' selects='+sels.length+' greens='+greens.length+' -> cards='+cards.length);
    return cards;
  }

  // ---------- matcher ----------
  function resolveRow(card){
    if (!INDEX) return null;
    const rawTitle = (nameEl(card)?.textContent || '').trim();
    if (!rawTitle || looksLikeNoise(rawTitle)) return null;

    const alias = ALIAS[rawTitle] || rawTitle;
    const key   = normBase(alias);
    const toks  = tokensOf(alias);
    if (!toks.length) return null;

    let best = null, bestScore = -1;

    for (const e of INDEX){
      // Jaccard-ish + numeric boost
      let inter = 0, nums = 0;
      for (const t of toks){
        if (e.toks.has(t)){ inter++; if (/^\d+$/.test(t)) nums++; }
      }
      const union = new Set([...toks, ...e.toks]).size;
      const j = union ? inter/union : 0;
      const score = j + nums*0.25 + (inter>=2?0.1:0); // gentle bias
      if (score > bestScore){ bestScore = score; best = e; }
    }

    // Accept with a low but safe threshold (handles Ct/Count etc.)
    if (bestScore >= 0.32) return best.row;
    return null;
  }

  // ---------- writers ----------
  function setGreen(el, num){
    if (!el) return;
    el.textContent = fmt(num);
    try{
      const cls = el.classList;
      const has = Array.from(cls).some(c => c === 'text-success' || c.startsWith('text-green'));
      if (!has) cls.add('text-green-600','font-semibold');
    }catch{}
  }

  function stampPriceTargets(card, price){
    card.querySelectorAll('button').forEach(btn=>{
      ['data-price','data-amount','data-value'].forEach(a => btn.setAttribute(a, String(price)));
      btn.dataset.price = String(price);
    });
    card.querySelectorAll('[data-price],[data-amount],[data-value]').forEach(n=>{
      ['data-price','data-amount','data-value'].forEach(a => n.setAttribute(a, String(price)));
      n.dataset.price = String(price);
    });
    card.querySelectorAll('input[type="hidden"]').forEach(h=>{
      const idc = (h.id||'') + ' ' + (h.name||'') + ' ' + (h.className||'');
      if (/price|amount|value/i.test(idc)) h.value = String(price);
    });
  }

  function rewriteOptions(card, row){
    const sel = card.querySelector('select'); if (!sel) return 0;
    let changed = 0;
    [...sel.options].forEach(opt=>{
      const cat = opt.dataset.psCat || baseLabel(opt.textContent);
      opt.dataset.psCat = cat;
      const col = labelToCol(cat);
      const val = row[col] ?? row.p9;
      if (val != null){
        const next = `${cat} - ${fmt(val)}`;
        if (opt.textContent !== next) changed++;
        opt.textContent = next; opt.label = next; opt.text = next; opt.value = String(val);
        ['data-price','data-amount','data-value'].forEach(a => opt.setAttribute(a, String(val)));
        opt.dataset.price = String(val);
      }
    });
    sel.dispatchEvent(new Event('input',  { bubbles:true }));
    sel.dispatchEvent(new Event('change', { bubbles:true }));
    return changed;
  }

  function syncCard(card, row){
    const gre = priceEl(card);
    const sel = card.querySelector('select');
    // if no select rendered yet, default to 9+ months
    let val = row.p9;
    if (sel && sel.options.length){
      const opt = sel.selectedOptions[0] || sel.options[sel.selectedIndex];
      const cat = (opt?.dataset.psCat) || baseLabel(opt?.textContent || '9+ months');
      val = row[labelToCol(cat)] ?? row.p9;
    }
    if (val == null) return false;
    setGreen(gre, val);
    stampPriceTargets(card, val);
    // also store for cart override map
    const title = (nameEl(card)?.textContent || '').trim();
    if (title) PRICE_HINTS.set(title, val);
    return true;
  }

  // ---------- cart sync ----------
  const cartRoot = () =>
    document.querySelector('[role="dialog"], [aria-modal="true"], [class*="drawer"], [data-cart], .cart');

  function dollarNodes(scope){
    return [...scope.querySelectorAll('*')].filter(n => /\$\s*\d/.test((n.textContent||'').trim()));
  }
  function itemTitle(item){
    const t = item.querySelector('h1,h2,h3,h4,.title,.font-medium,[data-product-name]');
    return (t?.textContent || '').trim();
  }
  function itemExpiry(item){
    const m = [...item.querySelectorAll('*')].find(n => /^Expiration:/i.test((n.textContent||'').trim()));
    if (!m) return '9+ months';
    const after = (m.textContent||'').split(':').slice(1).join(':').trim();
    if (/7\s*[-–]?\s*8/.test(after)) return '7-8 months';
    if (/6/.test(after))           return '6 months';
    return '9+ months';
  }

  const PRICE_HINTS = new Map(); // title -> last seen price on card

  function syncCart(){
    const root = cartRoot(); if (!root || !INDEX) return;
    const items = [...root.querySelectorAll('*')]
      .filter(n => /^Expiration:/i.test((n.textContent||'').trim()))
      .map(n => n.closest('*')).filter(Boolean);

    let changed = 0;
    for (const item of items){
      const title = itemTitle(item);
      let want = PRICE_HINTS.get(title);

      if (want == null){
        const row = resolveRow({ // fake “card” just to reuse matcher
          querySelector: (sel) => sel ? null : null,
          get textContent(){ return title; }
        }) || null;
        if (row){
          const label = itemExpiry(item);
          want = ( row[labelToCol(label)] ?? row.p9 );
        }
      }
      if (want == null) continue;

      dollarNodes(item).forEach(n => {
        if (n.textContent.trim() !== fmt(want)){
          n.textContent = fmt(want);
          changed++;
        }
      });
    }
    if (changed) console.log('[ps-sync v7.5] cart updated $ nodes:', changed);
  }

  document.addEventListener('click', e => {
    const b = e.target.closest('button');
    if (b && /add to sale/i.test(b.textContent||'')){
      setTimeout(syncCart, 250);
      setTimeout(syncCart, 700);
    }
  });

  // ---------- main ----------
  function tinyParseCSV(txt){
    const lines = txt.split(/\r?\n/).filter(Boolean);
    const hdr = (lines.shift() || '').split(',').map(h=>h.trim());
    return lines.map(line => {
      const cols = line.split(',');
      const o = {}; hdr.forEach((h,i)=> o[h] = (cols[i] ?? '').trim());
      return o;
    });
  }

  function applyAll(tag=''){
    const cards = findCards();
    let rew=0, upd=0, miss=[];
    for (const c of cards){
      const row = resolveRow(c);
      if (!row){ miss.push((nameEl(c)?.textContent||'').trim()); continue; }
      rew += rewriteOptions(c, row);
      if (syncCard(c, row)) upd++;
    }
    console.log(`[ps-sync v7.5] cards:${cards.length} optionsRewritten:${rew} greenUpdated:${upd}` + (tag?` (${tag})`:``));
    if (miss.length) console.warn('[ps-sync v7.5] titles NOT matched (add ALIAS if needed):', miss);
  }

  function start(){
    const run = rows => { INDEX = buildIndex(rows); applyAll('initial'); setTimeout(()=>applyAll('recheck'), 400); };

    if (window.Papa){
      Papa.parse(CSV_URL + '&cb=' + Date.now(), {
        download:true, header:true, skipEmptyLines:true,
        complete: res => run(res.data),
        error: e => console.error('[ps-sync v7.5] CSV load error', e),
      });
    } else {
      fetch(CSV_URL + '&cb=' + Date.now())
        .then(r => r.ok ? r.text() : Promise.reject(r.status))
        .then(t => run(tinyParseCSV(t)))
        .catch(e => console.error('[ps-sync v7.5] CSV fetch error', e));
    }
  }

  setTimeout(start, 400);

  const mo = new MutationObserver(() => { clearTimeout(mo.t); mo.t = setTimeout(()=>applyAll('mutation'), 140); });
  mo.observe(document.body, { childList:true, subtree:true });

  window.__PS_FORCE__ = () => applyAll('manual');
})();
</script>







</body>

</html>
